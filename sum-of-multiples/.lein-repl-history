(def sample-digits '(3 5))
(partial map sample-digits)
(apply (partial map sample-digits) 3)
(defn multiple-of? [d n] (= (mod n d) 0))
(multiple-of? 3 15)
(multiple-of? 3 14)
(partial multiple-of? 3)
(map #(partial multiple-of? %) sample-digits)
(juxt (map #(partial multiple-of? %) sample-digits) 15)
((juxt (map #(partial multiple-of? %) sample-digits)) 15)
(map #(partial multiple-of? %) sample-digits)
((juxt (map #(partial multiple-of? %) sample-digits)) 15)
(juxt [(partial multiple-of? 3) (partial multiple-of? 5)])
((juxt [(partial multiple-of? 3) (partial multiple-of? 5)]) 15)
(for [fn (map (partial multiple-of) sample-digits)] [fn])
(for [fn (map (partial multiple-of?) sample-digits)] [fn])
(for [fn (map partial multiple-of?) sample-digits)] [fn])
(for [fn ((map partial multiple-of?) sample-digits)] [fn])
(map #(partial multiple-of? %) sample-digits)
(def f (juxt (map #(partial multiple-of? %) sample-digits)))
(f 10)
(for [d sample-digits] (= (mod 10 d)))
(for [d sample-digits] (= 0 (mod 10 d)))
(defn multiple-of? [digits n]
  (some identity (for [d digits] (= 0 (mod n d)))))
(multiple-of? '(3 5) 10)
(defn multiple-of? [digits n]
(filter (partial multiple-of? '(3 5)) (range 20))
(filter (partial multiple-of? '(3 5)) (range 1 20))
(reduce + (filter (partial multiple-of? '(3 5)) (range 1 20)))

(def single-digits (range 1 10))
(into [] single-digits)
(armstrong?)
(armstrong?
2)
(defn armstring [n]
(defn armstrong [n]
   (let [as-str (str n)
         length (count as-str)
         digits (into [] (map Integer/parseInt as-str))]
   )
    (reduce + digits))
Integer/parseInt
((. Integer parseInt) "32")
((. Integer parseInt "32"))
(. Integer parseInt)
(Integer/parseInt "32")
(defn armstrong [n]
  #_=>    (let [as-str (str n)
  #_=>          length (count as-str)
  #_=>          digits (into [] (map Integer/parseInt as-str))]
  #_=>    )
(defn armstrong [n]
  (let [s (str n)
        length (count s)
        digits (into [] (map #(Integer/parseInt %) s)))
        digits (into [] (map #(Integer/parseInt %) s))]
(defn armstrong [n]
  (let [s (str n)
        length (count s)
        digits (into [] (map #(Integer/parseInt %) s))]
   (reduce + digits))
)
(armstrong 5)
(str 34)
(def s (str 34))
s
(def length (count s))
length
(into [] (map #(Integer/parseInt %) s))
(into [] (map #(Integer/parseInt %) (seq s)))
(into [] (map #(Integer/parseInt (str %)) (seq s)))
(into [] (map #(Integer/parseInt (str %))seq s))
(into [] (map #(Integer/parseInt (str %)) s))
(require ns-armstrong)
(armstrong?)
(armstrong-numbers/armstrong?)
(require '[armstrong-numbers :as a])
(defn armstrong? [num]
    let [s (str num)
         length (count s)
         digits (into-vec (map parse-int s))
         powsum (sum-of-powers digits length)]
    (= powsum num))
(defn pow [x n]
  (reduce * (repeat n x)))
(defn parse-int [c]
  (Integer/parseInt (str c)))
(defn sum-of-powers [xs power]
  (reduce + (map #(pow % length) xs)))
(defn into-vec [args]
(require '[armstrong-numbers :as a])
(defn armstrong? [n]
   (let [s (str n)
         length (count s)
        ])
   [s length])
(defn armstrong? [n]
   (let [s (str n)
         length (count s)]
    [s length]))
(armstrong? 123)
(def x 32013)
x
(defn number-of-digits [n]
(loop [x 342]
  (when (> x 1)
  (println x)
  (recur (/ x 10))))
(loop [x 342]
  (when (> x 1)
  (recur (/ x 10) x))))
(loop [x 342]
  (when (> x 1)
  (recur (/ x 10) x)))
(loop [x 342]
  (when (> x 1)
  (recur (/ x 10)) x))
(loop [x 342]
  (when (> x 1)
  (recur (/ x 10)
  x)))
(loop [x 342]
  (if (zero? x)
   nil
   (recur (/ x 10))))
(loop [x 342]
  (if (< x 1)
  nil
  (recur (/ x 10))))
(/ 342 10)
(quot 342 10)
(mod 342 10)
(mod 34 10)
(mod 4 10)
(mod 3 10)
(quot 3 10)
(defn digits [n]
  (loop [x n]
(iterate (mod 342 10))
(iterate #(mod % 10) 342)
(take-while #(not (zero? %)) (interate #(mod % 10) 342))
(take-while #(not (zero? %)) (iterate #(mod % 10) 342))
(loop [n 342 result []]
  if(zero? n)
   result
   (recur (quot n 10) (conj result (mod n 10))))
(loop [n 342 result []]
  (if zero? n)
   result
   (recur (quot n 10) (conj result (mod n 10))))
(quot 342 10)
[(quot 342 10) (mod 342 10)]
(loop [n 342]
(loop [n 342 result []]
(loop [n 342 iter 0 result []]
  (if (>= iter 3)
   result 
   (recur (quot n 10) (inc iter) (conj result (mod n 10)))))
(loop [n 342 iter 0 result []]
  (println n iter result)
  (if (>= iter 3)
   result
   (recur (quot n 10) (inc iter) (conj result (mod n 10)))))
(loop [n 342 result []]
  (if (<= n 0)
   (reverse result)
   (recur (quot n 10) (conj result (mod n 10))))
)
_
(_)
(count '(3 4 2))
(count (3 4 2))
(count '(3 4 2))
(count (lst 3 4 2))
(list 3 4 2)
(count (list 3 4 2))
(ns armstrong-numbers)
(require '[armstrong-numbers.armstrong?])
(in-ns armstrong-numbers)
*ns*
(in-ns 'armstrong-numbers)
(armstrong-numbers/armstrong? 321)
(require '[armstrong-numbers :as a])
(a/armstrong? 321)

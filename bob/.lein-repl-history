(defn question? [s]
  (= (last (clojure.string/trim s)) \?))
(question? "I like cheese.")
(question? "I like cheese?")
(question? "I like cheese?           ")
(remove (set "ut") "Justin")
(str (remove (set "ut") "Justin"))
(apply str (remove (set "ut") "Justin"))
(remove (set "12") "4?")
(remove (set "124") "4?")
(remove (set ",.!") "1, 2, 3")
(apply str (remove (set ",.!") "1, 2, 3"))
(use 'bob)
(bob/response-for "1, 2, 3")
(bob/yelling? "1, 2, 3")
(bob/yelling? (remove (conj bob/digits bob/punctuation) "1, 2, 3"))
(use 'bob)
(bob/yelling? (remove (conj bob/digits bob/punctuation) "1, 2, 3"))
(bob/yelling? (apply str (remove (conj bob/digits bob/punctuation) "1, 2, 3")))
bob/punctuation 
(remove bob/punctuation "1, 2, 3")
(apply str (remove bob/punctuation "1, 2, 3"))
(conj bob/digits bob/punctuation)
(bob/yelling? (apply str (remove (union bob/digits bob/punctuation) "1, 2, 3")))
(bob/yelling? (apply str (remove (clojure.set/union bob/digits bob/punctuation) "1, 2, 3")))
(def to-remove #{! # , . 0 1 2 3 4 5 6 7 8 9})
(def to-remove #{\! \# \, \. \0 \1 \2 \3 \4 \5 \6 \7 \8 \9})
to-remove
(remove to-remove "1, 2, 3")
(apply str (remove to-remove "1, 2, 3"))
(use bob :as b)
(use 'bob :as b)
(use '[bob :as b])
(def conditions [b/yelling? b/question? empty?])
(map "" conditions)
(apply conditions "")
(apply comp conditions)
((apply comp conditions) "")
(apply juxt conditions)
((apply juxt conditions) "")
(every? ((apply juxt conditions) ""))
(every ((apply juxt conditions) ""))
(reduce #(and %2 %1) ((apply juxt conditions) ""))
(apply and [false true false])
(every identity [false true false])
(every-pred identity [false true false])
(every? identity [false true false])
(every? identity [true true true])
(apply #(eval (list* 'or %&)) [true false])
(some identity [false true false])
((apply juxt conditions) "")
(reduce #(and %1 %2) ((apply juxt conditions) ""))
(def conditions (hash-map :is-question b/question? :is-yelling b/yelling? ))
conditions
(reduce #(and %1 %2) ((apply juxt conditions) ""))
(apply conditions "")
(reduce-kv println conditions)
(help cond->)
(use '[clojure.java.io : io])
(use '[clojure.java.io :as io])
(io/file "./project.clj")
(read (io/file "./project.clj"))
(slurp "./project.clj")
(clojure.pprint/pprint (slurp "./project.clj"))
(io/reader "./project.clj")
(read (io/reader "./project.clj"))
(with-open [rdr (io/reader "foo.txt")]
(with-open [rdr (io/reader "./project.clj")]
  (doall (map println (line-seq rdr))))
(with-open [rdr (io/reader "foo.txt")]
(with-open [rdr (io/reader "./project.clj")]
  (doall (line-seq rdr)))
(with-open [rdr (io/reader "./project.clj")]
  (line-seq rdr))
(def reader (io/reader "./project.clj"))
(def rdr (io/reader "./project.clj"))
(line-seq rdr)
(type (line-seq rdr))
(reduce + (range 1 100))
(reduce + (range 1 (inc 100)))
(def sum 
 ([start end] (reduce + (range start (inc end))))
 ([end] (sum 0 end)))
(defn sum 
 ([start end] (reduce + (range start (inc end))))
 ([end] (sum 0 end)))
(sum 1 100)
(sum 1)
(sum 100)
(sum 10)
(defn zip [& colls]
(apply interleave "abc" "123" "efg")
(apply interleave ["abc" "123" "efg"])
(partition 3 3 (apply interleave ["abc" "123" "efg"]))
(take-while (complement nil?) (partition 3 3 (apply interleave ["abc" "123" "efg"])))
(take-while (complement nil?) (partition 3 3 (apply interleave ["abc" "123" "efgasdf"])))
(take-while (complement nil?) (partition 3 3 (apply interleave ["abc" "123as" "efgasdf"])))
(take-while (complement nil?) (partition 3 3 (apply interleave ["abcwer" "123as" "efgasdf"])))
(defn zip [& colls]
  (->> colls
    (apply interleave)
    (paritition (count colls) (count colls))
    (take-while (complement nil?))))
(defn zip [& colls]
  (->> colls
    (apply interleave)
    (partition (count colls) (count colls))
    (take-while (complement nil?))))
(zip "abc" [1 2 3])
(into {} (zip "abc" [1 2 3]))
(into {} (zip (split-at "" "abc") [1 2 3]))
(clojure.string/split "" "abc")
(clojure.string/split #"" "abc") 
(zip [1 2 3] [4 5 6] (map str "abc"))
(into {} (zip (map str "abc") [1 2 3]))
(into [] (zip (map str "abc") [1 2 3]))
(map vec (zip (map str "abc") [1 2 3]))
(into {} (map vec (zip (map str "abc") [1 2 3])))
(->> (zip (map str "abc") [1 2 3])
     (map vec)
     (into []))
(conj "abc" "def")
(conj (seq "abc") (seq "def"))
(apply conj (seq "abc") (seq "def"))
(apply conj (vec "abc") (vec "def"))
(apply (comp str conj) (vec "abc") (vec "def"))
(use 'bob)
(bob/clean "4?")
(bob/question? (bob/clean "4?"))
(let [cleaned (bob/clean "4?")]
 (and (bob/question? cleaned) ((complement bob/yelling?) cleaned)))
vim sr

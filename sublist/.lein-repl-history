(require '[sublist :as s])
(s/chunk 3 [0 2 1 3 4 2])
(drop 3 [1 2 1 2 30])
(take 3 (drop 1 [1 2 1 2 30]))
(take 3 (drop 2 [1 2 1 2 30]))
(take 3 (drop 3 [1 2 1 2 30]))
(take 3 (drop 4 [1 2 1 2 30]))
(defn chunk [n lst]
  (map #(take n (drop (.indexOf % lst) lst)) lst)
)
(chunk 3 [1 2 3 4 5 6])
(defn index-of [n lst]
  (.indexOf lst n))
(defn chunk [n lst]
  (map #(take n (drop (index-of n lst) lst)) lst))
(chunk 3 (into [] (range 1 11)))
(index-of 1 [ 1 2 3 4 2 3])
(map-indexed #(take 3 (drop %1 lst)) lst)
(def lst [1 2 3 4 5 6 7 8 9 10])
(map-indexed #(take 3 (drop %1 lst)) lst)
(map-indexed (fn [idx _] (take 3 (drop idx lst))) lst)
(filter #(= (count %) 3) (map-indexed (fn [idx _] (take 3 (drop idx lst))) lst)
)
(require '[sublist :as s])
(def first [1 2 3])
(def second [1 2 3])
(s/equal? first second)
(s/equal-length? first second)
(s/elements-are-equal? first second)
(def first [1 2 3])
(def second [1 2 3])
(= first second)

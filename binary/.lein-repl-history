(use '[binary :refer [power]])
(power 3 2)
(def sample "100)
(def sample "100")
(->> sample
     (reverse))
(->> sample
     (reverse)
     (map int))
(->> sample
     (reverse)
     (map Integer/parseInt))
java.lang.Integer
java.lang.Integer/parseInt
((. java.lang.Integer parseInt) "10")
(. java.lang.Integer parseInt ) 
(. java.lang.Integer parseInt "10") 
(defn parse-int [n] (. Integer parseInt n))
(parse-int "10")
(parse-int "-12")
(seq "100")
(apply str (seq "100"))
(map int "100)
(map int "100")
(map #(- (int %) 48) "100")
(def transform #(- (int %) 48))
(map transform (reverse "100"))
(require '[binary :as b])
(b/power 3 2)
(b/to-decimal "100")
(require '[binary :as b])
(b/to-decimal "100")
(require '[binary :as b])
(b/to-decimal "100")
(require '[binary :as b])
(b/to-decimal "100")
(def bits (b/to-decimal "100"))
bits
(map-indexed (fn [idx n] (n * (b/power 2 idx))))
(into [] (map-indexed (fn [idx n] (n * (b/power 2 idx)))))
(map-indexed (fn [idx n] (n * (b/power 2 idx))) (b/decimal "100"))
(map-indexed (fn [idx n] (n * (b/power 2 idx))) (b/to-decimal "100"))
(map-indexed (fn [idx n] (* n (b/power 2 idx))) (b/to-decimal "100"))
(map-indexed #(* %2 (b/power 2 %1)) (b/to-decimal "100"))
(require '[binary :as b])
(b/to-decimal "100")
(b/to-decimal "101")
(int \c)
(int \0)
(int \1)
(set "100")
(require [clojure.set :refer [subset?]])
(require '[clojure.set :refer [subset?]])
(subset? (set "100") #{\0 \1})
(subset? (set "carrot") #{\0 \1})
